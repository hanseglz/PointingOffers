
public class Test14_1 {
    /**
     * 给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n>1并且m>1），每段绳子的长度记为 k[0],k[1]...k[m-1] 。
     * 请问 k[0]*k[1]*...*k[m-1] 可能的最大乘积是多少？
     * 例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。
     *
     * 2 <= n <= 58
     */
    public static int cuttingRope(int n){
        /**
         * 数学规划/贪心算法
         * 通过数学推导可得，当每段绳长均为e时，可得到乘积最大值，可参考f(x) = x^(1/x)的图形
         * 然而题目要求每段绳长为整数，在f(x) = x^(1/x)的图形中，f(3) > f(2)，所以应该尽量使每段绳长为3
         * 又因为3 * 1 < 2 * 2，所以当最后剩下的绳长为1时，应该取出一段长为3的绳子，将其合并并拆分成两个绳长为2的绳子
         * 综上，算法可以概括为：
         * 最优： 3 。把绳子尽可能切为多个长度为 3 的片段，留下的最后一段绳子的长度可能为 0,1,2三种情况。
         * 次优： 2 。若最后一段绳子长度为 2 ；则保留，不再拆为 1+1 。
         * 最差： 1 。若最后一段绳子长度为 1 ；则应把一份 3+1 替换为 2+2，因为 2×2>3×1。
         */
        if (n == 2)
            return 1;
        else if (n == 3)
            return 2;

        int res = 1;
        while (n >= 3){
            res *=3;
            n -= 3;
        }
        if (n == 2){
            res *= 2;
        }else if (n == 1){
            res = res / 3 * 2 * 2;
        }

        return res;
    }

    public static void main(String[] args) {
        System.out.println(cuttingRope(5));
    }
}
